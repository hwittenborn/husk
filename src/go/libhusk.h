/* Code generated by cmd/cgo; DO NOT EDIT. */

/* package github.com/hwittenborn/husk */


#line 1 "cgo-builtin-export-prolog"

#include <stddef.h>

#ifndef GO_CGO_EXPORT_PROLOGUE_H
#define GO_CGO_EXPORT_PROLOGUE_H

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef struct { const char *p; ptrdiff_t n; } _GoString_;
#endif

#endif

/* Start of preamble from import "C" comments.  */


#line 3 "misc.go"
 #include "husk.h"

#line 1 "cgo-generated-wrapper"

#line 3 "shell.go"
 #include "husk.h"

#line 1 "cgo-generated-wrapper"

#line 3 "syntax.go"
 #include "husk.h"

#line 1 "cgo-generated-wrapper"


/* End of preamble from import "C" comments.  */


/* Start of boilerplate cgo prologue.  */
#line 1 "cgo-gcc-export-header-prolog"

#ifndef GO_CGO_PROLOGUE_H
#define GO_CGO_PROLOGUE_H

typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoInt64 GoInt;
typedef GoUint64 GoUint;
typedef size_t GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
#ifdef _MSC_VER
#include <complex.h>
typedef _Fcomplex GoComplex64;
typedef _Dcomplex GoComplex128;
#else
typedef float _Complex GoComplex64;
typedef double _Complex GoComplex128;
#endif

/*
  static assertion to make sure the file is being used on architecture
  at least with matching size of GoInt.
*/
typedef char _check_for_64_bit_pointer_matching_GoInt[sizeof(void*)==64/8 ? 1:-1];

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef _GoString_ GoString;
#endif
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern "C" {
#endif


// Delete the object connected to a pointer.
//
extern void HuskMiscDeleteGoObj(ptr obj);

// Convert a `Stringer` pointer into a string.
//
extern char* HuskMiscStringerToString(ptr obj);

// Convert an `error` interface into a string.
//
extern char* HuskMiscErrorToString(ptr obj);

// Get a C string out of a Go string array.
//
// # Arguments
// - `array`: A pointer to the Go array.
// - `index`: The position of the item in the index to return.
//
// # Returns
// A pointer to the C string. It will be null if `index` isn't a valid index in the array.
extern char* HuskMiscGetStringFromArray(ptr array, int index);

// Get the Rust pointer for a `ReadContainer` from the Go `RustReaderError` object.
//
// # Arguments
// `obj`: The Go pointer
//
// # Returns
// The Rust pointer
//
extern void* HuskMiscGetReadContainerPtr(ptr obj);

/* Return type for HuskShellExpand */
struct HuskShellExpand_return {
	ptr r0;
	int r1;
};

// Wrapper around `shell.Expand`.
//
// # Arguments:
// - `shellString`: The string to be expanded.
// - `hmap`: A pointer to the Rust `HashMap` to read environment variables from.
//
// # Returns:
// - 0: A object pointing to the string/error.
// - 1: The type of the returned object.
//
extern struct HuskShellExpand_return HuskShellExpand(char* shellString, void* hmap);

/* Return type for HuskShellFields */
struct HuskShellFields_return {
	ptr r0;
	int r1;
};

// Wrapper around `shell.Fields`.
//
// # Arguments:
// - `shellString`: The string to be expanded.
// - `hmap`: A pointer to the Rust `HashMap` to read environment variables from.
//
// # Returns:
// - 0: A pointer to the Go object of the string array, or the error.
// - 1: Whether the returned string was the string array, or the error.
//
extern struct HuskShellFields_return HuskShellFields(char* shellString, void* hmap);

// Wrapper around `syntax.IsKeyword`.
//
// # Arguments:
// - `word`: The keyword to check.
//
// # Returns:
// - A boolean: `true` if the given word is part of the language keywords.
//
extern GoUint8 HuskSyntaxIsKeyword(char* word);

/* Return type for HuskSyntaxQuote */
struct HuskSyntaxQuote_return {
	ptr r0;
	int r1;
};

// Wrapper around `syntax.Quote`.
//
// # Arguments:
// - `inputString`: The string to quote.
// - `langVariantInt`: The language variant.
//
// # Returns:
// - 0: A pointer to the quoted string, or the error object.
// - 1: What kind of object `outputString` is.
//
extern struct HuskSyntaxQuote_return HuskSyntaxQuote(char* inputString, int langVariantInt);

/* Return type for HuskSyntaxQuoteErrorData */
struct HuskSyntaxQuoteErrorData_return {
	int r0;
	char* r1;
};

// Get the data out of a `syntax.QuoteError` pointer.
//
// # Returns
// 0. The byte offset of the error.
// 1. The error message.
//
extern struct HuskSyntaxQuoteErrorData_return HuskSyntaxQuoteErrorData(ptr obj);

// Wrapper around `syntax.ValidName`.
//
// # Arguments:
// - `value`: The value to check.
//
// # Returns:
// - A boolean, `true` if `value` is a valid name.
//
extern GoUint8 HuskSyntaxValidName(char* value);

// Wrapper around `syntax.LangVariant.String`.
//
// # Arguments
// - `variant`: The integer for the language variant.
//
// # Returns
// - The string
//
extern char* HuskSyntaxLangVariantString(int variant);

// Wrapper around `syntax.NewPos`.
//
// # Arguments
// - `offset`: The offset position.
// - `line`: The line position.
// - `column`: The column position.
//
// # Returns
// A pointer to the `syntax.Pos` object.
//
extern ptr HuskSyntaxNewPos(unsigned int offset, unsigned int line, unsigned int column);

// Wrapper around `syntax.Pos.After`.
//
// # Arguments
// - `pos1`: A pointer to the first `syntax.Pos` object.
// - `pos2`: A pointer to the second `syntax.Pos` object.
//
// # Returns
// A boolean, indicating if `pos1` is after `pos2`.
//
extern GoUint8 HuskSyntaxPosAfter(ptr pos1, ptr pos2);

// Wrapper around `syntax.Pos.Col`.
//
// # Arguments
// - `obj`: A pointer to the `syntax.Pos` object.
//
// # Returns
// The column number of the position.
//
extern unsigned int HuskSyntaxPosCol(ptr obj);

// Wrapper around `syntax.Pos.Line`.
//
// # Arguments
// - `obj`: A pointer to the `syntax.Pos` object.
//
// # Returns
// The line number of the position.
//
extern unsigned int HuskSyntaxPosLine(ptr obj);

// Wrapper around `syntax.Pos.Offset`.
//
// # Arguments
// - `obj`: A pointer to the `syntax.Pos` object.
//
// # Returns
// The offset number of the position.
//
extern unsigned int HuskSyntaxPosOffset(ptr obj);

// Wrapper around `syntax.Pos.IsValid`.
//
// # Arguments
// - `obj`: A pointer to the `syntax.Pos` object.
//
// # Returns
// A boolean, representing if the position is valid.
//
extern GoUint8 HuskSyntaxPosIsValid(ptr obj);

// Wrapper around `syntax.NewParser`.
//
// # Arguments
// - `keepComments`: A pointer pointing to whether to keep comments.
// - `stopAt`: A pointer to the character to stop at.
// - `langVariant`: A pointer to the int of the language variant to use.
//
// Make any of the above pointers null to avoid using them.
//
// # Returns
// A pointer to the `*syntax.Parser` object.
//
extern ptr HuskSyntaxNewParser(GoUint8* keepComments, char* stopAt, int* langVariant);

/* Return type for HuskSyntaxParserParse */
struct HuskSyntaxParserParse_return {
	ptr r0;
	int r1;
};

// Wrapper around `syntax.Parser.parse`.
//
// # Arguments
// - `obj`: A pointer to the `*syntax.Parser` object.
// - `container`: A pointer to the rust `ReadContainer` object to read the bytes from.
// - `name`: The name of the shell program.
//
// # Returns
// - 0: A pointer to the Go object, containing either the `*File` or the error.
// - 1: The return type.
//
extern struct HuskSyntaxParserParse_return HuskSyntaxParserParse(ptr obj, void* container, char* name);

/* Return type for HuskSyntaxParseErrorData */
struct HuskSyntaxParseErrorData_return {
	char* r0;
	ptr r1;
	char* r2;
	GoUint8 r3;
};

// Get the data out of a `syntax.ParseError`.
//
// # Arguments
// - `obj`: A pointer to the `syntax.ParseError` object.
//
// # Returns
// - 0: The filename
// - 1: A pointer to the `syntax.Pos` object.
// - 2: The text
// - 3: Whether the error is from being incomplete.
//
extern struct HuskSyntaxParseErrorData_return HuskSyntaxParseErrorData(ptr obj);

#ifdef __cplusplus
}
#endif
